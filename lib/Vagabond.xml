<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Vagabond</name></assembly>
<members>
<member name="P:Nessos.Vagabond.AssemblyId.ImageHash">
<summary>
 digest of the raw assembly image
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyId.FullName">
<summary>
 assembly qualified name
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AssemblyId">
<summary>
 unique identifier for assembly
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AssemblyLoadInfo">
<summary>
 Assembly load information
</summary>
</member>
<member name="F:Nessos.Vagabond.AssemblyLoadPolicy.CacheOnly">
<summary>
 Assemblies are to be cached only, not loaded in AppDomain
</summary>
</member>
<member name="F:Nessos.Vagabond.AssemblyLoadPolicy.RequireIdentical">
<summary>
 If assembly is to be resolved locally, then it should have identical SHA256 hashcode.
</summary>
</member>
<member name="F:Nessos.Vagabond.AssemblyLoadPolicy.ResolveAll">
<summary>
 All assembly names can be looked up by runtime
</summary>
</member>
<member name="F:Nessos.Vagabond.AssemblyLoadPolicy.ResolveStrongNames">
<summary>
 Only signed assemblies should be looked up by runtime
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AssemblyLoadPolicy">
<summary>
 Specifies what assemblies are to be loaded 
 locally by the runtime if possible.
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyPackage.StaticInitializer">
<summary>
 Static initialization data
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyPackage.Symbols">
<summary>
 Symbols file
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyPackage.Image">
<summary>
 Raw image of the assembly
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AssemblyPackage">
<summary>
 Contains information necessary for the exportation of an assembly
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.FsiDynamicAssemblyProfile">
<summary>
 Dynamic Assembly profile for F# Interactive
</summary>
</member>
<member name="P:Nessos.Vagabond.IDynamicAssemblyProfile.Description">
<summary>
 a short description of the profile
</summary>
</member>
<member name="M:Nessos.Vagabond.IDynamicAssemblyProfile.PickleStaticField(System.Reflection.FieldInfo,System.Boolean)">
<summary>
 Specifies if static field is to be pickled
</summary>
</member>
<member name="M:Nessos.Vagabond.IDynamicAssemblyProfile.IsPartiallyEvaluatedSlice(Microsoft.FSharp.Core.FSharpFunc{System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.Assembly}},System.Reflection.Assembly)">
<summary>
 Decides if given slices requires fresh evaluation of assemblies
</summary>
</member>
<member name="M:Nessos.Vagabond.IDynamicAssemblyProfile.IsMatch(System.Reflection.Assembly)">
<summary>
 identifies dynamic assemblies that match this profile
</summary>
</member>
<member name="M:Nessos.Vagabond.IDynamicAssemblyProfile.EraseType(System.Type)">
<summary>
 Specifies if type is to be erased from slices
</summary>
</member>
<member name="M:Nessos.Vagabond.IDynamicAssemblyProfile.EraseStaticConstructor(System.Type)">
<summary>
 Specifies if static constructor is to be erased
</summary>
</member>
<member name="M:Nessos.Vagabond.IDynamicAssemblyProfile.AlwaysIncludeType(System.Type)">
<summary>
 Specifies if type is to be included in every iteration of the slice
</summary>
</member>
<member name="T:Nessos.Vagabond.IDynamicAssemblyProfile">
<summary>
 customizes slicing behaviour on given dynamic assembly
</summary>
</member>
<member name="P:Nessos.Vagabond.StaticInitializationInfo.Errors">
<summary>
 Static initialization errors
</summary>
</member>
<member name="P:Nessos.Vagabond.StaticInitializationInfo.IsPartial">
<summary>
 Is partial static initialization data
</summary>
</member>
<member name="P:Nessos.Vagabond.StaticInitializationInfo.Generation">
<summary>
 Generation of given static initializer
</summary>
</member>
<member name="T:Nessos.Vagabond.StaticInitializationInfo">
<summary>
 Static initialization metadata
</summary>
</member>
<member name="P:Nessos.Vagabond.StaticInitializer.IsPartial">
<summary>
 Is partial static initialization data
</summary>
</member>
<member name="P:Nessos.Vagabond.StaticInitializer.Data">
<summary>
 Static initialization data
</summary>
</member>
<member name="P:Nessos.Vagabond.StaticInitializer.Generation">
<summary>
 Generation of given static initializer
</summary>
</member>
<member name="T:Nessos.Vagabond.StaticInitializer">
<summary>
 static initialization data for assembly package
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Nessos.Vagabond.Vagabond.DefaultLoadPolicy(Nessos.Vagabond.AssemblyLoadPolicy)">
<summary>
 Default load policy 
</summary>
</member>
<member name="P:Nessos.Vagabond.Vagabond.UUId">
<summary>
 Unique identifier for the slice compiler
</summary>
</member>
<member name="P:Nessos.Vagabond.Vagabond.TypeConverter">
<summary>
 FsPickler type name converter for use with other formats
</summary>
</member>
<member name="P:Nessos.Vagabond.Vagabond.Pickler">
<summary>
 Returns the pickler used by the slice compiler
</summary>
</member>
<member name="P:Nessos.Vagabond.Vagabond.DefaultLoadPolicy">
<summary>
 Default load policy 
</summary>
</member>
<member name="P:Nessos.Vagabond.Vagabond.CachePath">
<summary>
 Cache directory used by Vagabond
</summary>
</member>
<member name="M:Nessos.Vagabond.Vagabond.TryGetSliceOfType(System.Type)">
 <summary>
     Returns the dynamic assembly slice corresponding to the given type, if exists.
 </summary>
 <param name="t">input type.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.ResolveDynamicDependenciesRequiringCompilation(System.Object)">
 <summary>
     Returns a list of dynamic assemblies that require slice compilation
     for the given object graph to be exportable.
 </summary>
 <param name="obj">any object graph</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.LoadCachedAssembly(Nessos.Vagabond.AssemblyId,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Loads an assembly that is already cached in local machine.
 </summary>
 <param name="id">input assembly id.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.LoadCachedAssemblies(System.Collections.Generic.IEnumerable{Nessos.Vagabond.AssemblyId},Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Loads assembly id's that are already cached in local machine.
 </summary>
 <param name="id">input assembly id.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.LoadAssemblyPackages(System.Collections.Generic.IEnumerable{Nessos.Vagabond.AssemblyPackage},Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Loads assembly packages to the local machine.
 </summary>
 <param name="pas">Input assembly packages.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.LoadAssemblyPackage(Nessos.Vagabond.AssemblyPackage,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Loads assembly package to the local machine.
 </summary>
 <param name="pa">Input assembly package.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.IsLocalDynamicAssemblySlice(Nessos.Vagabond.AssemblyId)">
 <summary>
     Checks if assembly id is a locally generated dynamic assembly slice.
 </summary>
 <param name="id">input assembly id.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.Initialize(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Nessos.Vagabond.IDynamicAssemblyProfile}},Microsoft.FSharp.Core.FSharpOption{Nessos.FsPickler.ITypeNameConverter},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Initializes a new Vagabond instance.
 </summary>
 <param name="ignoredAssemblies">Ignore assemblies and their dependencies.</param>
 <param name="cacheDirectory">Temp folder used for assembly compilation and caching. Defaults to system temp folder.</param>
 <param name="profiles">Dynamic assembly configuration profiles.</param>
 <param name="typeConverter">FsPickler type name converter.</param>
 <param name="requireLoadedInAppDomain">
     Demand all transitive dependencies be loadable in current AppDomain.
     If unset, only loaded assemblies are listed as dependencies. Defaults to true.
 </param>
 <param name="loadPolicy">Default assembly load policy.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.Initialize(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Nessos.Vagabond.IDynamicAssemblyProfile}},Microsoft.FSharp.Core.FSharpOption{Nessos.FsPickler.ITypeNameConverter},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Initializes a new Vagabond instance.
 </summary>
 <param name="cacheDirectory">Temp folder used for assembly compilation and caching. Defaults to system temp folder.</param>
 <param name="profiles">Dynamic assembly configuration profiles.</param>
 <param name="typeConverter">FsPickler type name converter.</param>
 <param name="isIgnoredAssembly">User-defined assembly ignore predicate.</param>
 <param name="requireLoadedInAppDomain">
     Demand all transitive dependencies be loadable in current AppDomain.
     If unset, only loaded assemblies are listed as dependencies. Defaults to true.
 </param>
 <param name="loadPolicy">Default assembly load policy.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.GetDynamicAssemblySlices(System.Reflection.Assembly)">
 <summary>
     Returns *all* assembly slices of given dynamic assembly.
 </summary>
 <param name="assembly">a dynamic assembly.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.GetAssemblyLoadInfo(System.Collections.Generic.IEnumerable{Nessos.Vagabond.AssemblyId},Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Gets the local assembly load info for given assembly ids.
 </summary>
 <param name="ids">Given assembly ids.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.GetAssemblyLoadInfo(Nessos.Vagabond.AssemblyId,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Gets the local assembly load info for given assembly id.
 </summary>
 <param name="id">Given assembly id.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.CreateAssemblyPackages(System.Collections.Generic.IEnumerable{Nessos.Vagabond.AssemblyId},System.Boolean,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Creates assembly packages out of given assembly ids.
 </summary>
 <param name="ids"></param>
 <param name="includeAssemblyImage">Include raw assembly image in the bundle.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.CreateAssemblyPackage(System.Reflection.Assembly,System.Boolean)">
 <summary>
     Builds an assembly package bundle for given input.
 </summary>
 <param name="assembly">Given assembly.</param>
 <param name="includeAssemblyImage">Include raw assembly image in the bundle.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.CreateAssemblyPackage(Nessos.Vagabond.AssemblyId,System.Boolean,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Creates an assembly package out of a given assembly id.
 </summary>
 <param name="id">assembly id</param>
 <param name="includeAssemblyImage">include assembly image in assembly package.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.ComputeObjectDependencies(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
     Returns a collection of all assemblies that the given object depends on.
     Dynamic assemblies are substituted for their corresponding static slices.
 </summary>
 <param name="obj">A given object graph</param>
 <param name="permitCompilation">Compile new slices as required. Defaults to false.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.CompileDynamicAssemblySlice(System.Reflection.Assembly)">
 <summary>
     Compiles slices for given dynamic assembly, if required.
 </summary>
 <param name="assembly">a dynamic assembly</param>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.Vagabond">
<summary>
 Vagabond Object which instantiates a dynamic assembly compiler, loader and exporter state
</summary>
</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.VagabondException">
<summary>
 Exception raised by Vagabond
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AssemblyCache">

</member>
<member name="P:Nessos.Vagabond.AssemblyManagement.VagabondState.RequireDependenciesLoadedInAppDomain">
<summary>
 result in failure if any of the listed transitive
 cannot be loaded in the local AppDomain.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.AssemblyManagement.exportAssembly(Nessos.Vagabond.AssemblyManagement.VagabondState,Nessos.Vagabond.AssemblyLoadPolicy,System.Boolean,Nessos.Vagabond.AssemblyId)">
<summary>
 exports an assembly package

</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyManagement.registerAssemblyResolutionHandler">
<summary>
 registers an assembly resolution handler based on AppDomain lookups;
 this is needed since assembly lookups often fail when loaded at runtime.
</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyManagement">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.AssemblyParser.parseDynamicAssemblySlice(Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState,System.Reflection.Assembly)">
<summary>
 the main assembly parsing method
</summary>
</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.AssemblyParser.computeSliceData(Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyState)">
<summary>
 traverses a dynamic assembly and compiles and index of parse information
 to be used for the assembly parser configuration
</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyParser">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.Daemon">

</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.DependencyAnalysis.remapDependencies(Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean},System.Boolean,Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Reflection.Assembly,System.Collections.Generic.IEnumerable{System.Type}}})">
<summary>
 reassigns assemblies so that the correct assembly slices are matched
</summary>
</member>
<member name="M:Nessos.Vagabond.DependencyAnalysis.getDynamicDependenciesRequiringCompilation(Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Reflection.Assembly,System.Collections.Generic.IEnumerable{System.Type}}})">
<summary>
 determines the assemblies that require slice compilation based on given dependency input
</summary>
</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.DependencyAnalysis.parseDynamicAssemblies(Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean},System.Boolean,Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
<summary>
 parse a collection of assemblies, identify the dynamic assemblies that require slice compilation
 the dynamic assemblies are then parsed to Cecil and sorted topologically for correct compilation order.
</summary>
</member>
<member name="M:Nessos.Vagabond.DependencyAnalysis.traverseDependencies(Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean},System.Boolean,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState},System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
<summary>
 recursively traverse assembly dependency graph
</summary>
</member>
<member name="M:Nessos.Vagabond.DependencyAnalysis.tryResolveAssembly(Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean},System.Boolean,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState},System.String)">
<summary>
 locally resolve an assembly by qualified name
</summary>
</member>
<member name="P:Nessos.Vagabond.DependencyAnalysis.isIgnoredAssembly">
<summary>
 assemblies ignored by Vagabond during assembly traversal
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.DependencyAnalysis">

</member>
<member name="M:Nessos.Vagabond.Extras.Utilities.ComputeTypeDependencies(System.Object)">
 <summary>
     Returns all type instances that appear in given object graph.
 </summary>
 <param name="obj">object graph to be traversed</param>
</member>
<member name="M:Nessos.Vagabond.Extras.Utilities.ComputeAssemblyId(System.Reflection.Assembly)">
 <summary>
     Computes a unique id for given static assembly.
 </summary>
 <param name="assembly">a static assembly.</param>
</member>
<member name="M:Nessos.Vagabond.Extras.Utilities.ComputeAssemblyDependencies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean}},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
     Resolves all assembly dependencies of given assemblies.
 </summary>
 <param name="assemblies"></param>
 <param name="isIgnoredAssembly">User-defined assembly ignore predicate.</param>
 <param name="requireLoadedInAppDomain">
     Demand all transitive dependencies be loadable in current AppDomain.
     If unset, only loaded assemblies are listed as dependencies. Defaults to true.
 </param>
</member>
<member name="M:Nessos.Vagabond.Extras.Utilities.ComputeAssemblyDependencies(System.Reflection.Assembly,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean}},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
     Resolves all assembly dependencies of given assembly.
 </summary>
 <param name="assembly">assembly to be traversed</param>
 <param name="isIgnoredAssembly">User-defined assembly ignore predicate.</param>
 <param name="requireLoadedInAppDomain">
     Demand all transitive dependencies be loadable in current AppDomain.
     If unset, only loaded assemblies are listed as dependencies. Defaults to true.
 </param>
</member>
<member name="M:Nessos.Vagabond.Extras.Utilities.ComputeAssemblyDependencies(System.Object,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean}},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
     Resolves all assembly dependencies of given object graph.
 </summary>
 <param name="obj">object graph to be traversed</param>
 <param name="isIgnoredAssembly">User-defined assembly ignore predicate.</param>
 <param name="requireLoadedInAppDomain">
     Demand all transitive dependencies be loadable in current AppDomain.
     If unset, only loaded assemblies are listed as dependencies. Defaults to true.
 </param>
</member>
<member name="T:Nessos.Vagabond.Extras.Utilities">
 <summary>
     A collection of general purpose utilities on dependency traversal.
 </summary>
</member>
<member name="M:Nessos.Vagabond.Extras.IRemoteAssemblyPublisher.PullAssemblies(Microsoft.FSharp.Collections.FSharpList{Nessos.Vagabond.AssemblyId})">
<summary>
 request assembly packages from publisher
</summary>
</member>
<member name="M:Nessos.Vagabond.Extras.IRemoteAssemblyPublisher.GetRequiredAssemblyInfo">
<summary>
 receives a collection of dependencies required by remote publisher
</summary>
</member>
<member name="T:Nessos.Vagabond.Extras.IRemoteAssemblyPublisher">
<summary>
 Defines an abstract assembly exporter; to be used by VagabondClient
</summary>
</member>
<member name="M:Nessos.Vagabond.Extras.IRemoteAssemblyReceiver.PushAssemblies(Microsoft.FSharp.Collections.FSharpList{Nessos.Vagabond.AssemblyPackage})">
<summary>
 upload a set of assembly packages to the remote party
</summary>
</member>
<member name="M:Nessos.Vagabond.Extras.IRemoteAssemblyReceiver.GetLoadedAssemblyInfo(Microsoft.FSharp.Collections.FSharpList{Nessos.Vagabond.AssemblyId})">
<summary>
 receives the assembly load state of the remote party for the given id&apos;s
</summary>
</member>
<member name="T:Nessos.Vagabond.Extras.IRemoteAssemblyReceiver">
<summary>
 Defines an abstract assembly load target; to be used by VagabondServer
</summary>
</member>
<member name="M:Nessos.Vagabond.Extras.Vagabond.ReceiveDependencies(Nessos.Vagabond.Vagabond,Nessos.Vagabond.Extras.IRemoteAssemblyPublisher,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Receive dependencies as supplied by the remote assembly publisher
 </summary>
 <param name="publisher">The remote publisher</param>
 <param name="loadPolicy">Specifies local assembly resolution policy. Defaults to strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.Extras.Vagabond.SubmitObjectDependencies(Nessos.Vagabond.Vagabond,Nessos.Vagabond.Extras.IRemoteAssemblyReceiver,System.Object,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
     Apply the built-in assembly distribution protocol using user-defined function.
 </summary>
 <param name="receiver">User provided assembly submit operation.</param>
 <param name="obj">Object, whose dependent assemblies are to be exported.</param>
 <param name="permitCompilation">Compile dynamic assemblies in the background, as required. Defaults to false.</param>
</member>
<member name="M:Nessos.Vagabond.Extras.Vagabond.SubmitAssemblies(Nessos.Vagabond.Vagabond,Nessos.Vagabond.Extras.IRemoteAssemblyReceiver,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
 <summary>
     Apply a built-in assembly distribution protocol using a user-defined submit function.
 </summary>
 <param name="receiver">User provided assembly submit operation.</param>
 <param name="assemblies">Assemblies to be exported.</param>
</member>
<member name="T:Nessos.Vagabond.Extras">
<summary>
 Collection of extensions and utilities for use with Vagabond
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.Serialization">

</member>
<member name="M:Nessos.Vagabond.SliceCompiler.compileDynamicAssemblySlices(Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean},System.Boolean,Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState,Microsoft.FSharp.Collections.FSharpList{System.Reflection.Assembly})">
<summary>
 compiles a collection of assemblies
</summary>
</member>
<member name="M:Nessos.Vagabond.SliceCompiler.compileDynamicAssemblySlice(Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState,Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyState,Microsoft.FSharp.Collections.FSharpMap{System.String,Nessos.Vagabond.AssemblyParser.TypeParseInfo},Mono.Cecil.AssemblyDefinition)">
<summary>
 compiles a slice of given dynamic assembly snapshot
</summary>
</member>
<member name="M:Nessos.Vagabond.SliceCompiler.initCompilerState(Microsoft.FSharp.Collections.FSharpList{Nessos.Vagabond.IDynamicAssemblyProfile},System.String)">
<summary>
 create an initial, empty compiler state
</summary>
</member>
<member name="T:Nessos.Vagabond.SliceCompiler">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.SliceCompilerTypes">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.Utils.AssemblyIdGenerator">
<summary>
 computes a unique assembly identifier
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Nessos.Vagabond.Utils.Exn`1.Value">
<summary>
 evaluate, re-raising the exception if failed
</summary>
</member>
<member name="T:Nessos.Vagabond.Utils.Exn`1">
<summary>
 Value or exception
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.Utils.tryGetTopologicalOrdering``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{``0}}})">
<summary>
 Attempt to compute a topological sorting for graph if DAG,
 If not DAG returns the reduced DAG for further debugging
</summary>
</member>
<member name="M:Nessos.Vagabond.Utils.tryLoadAssembly(System.String)">
<summary>
 try get assembly loaded in appdomain or load it now
</summary>
</member>
<member name="P:Nessos.Vagabond.Utils.tryGetLoadedAssembly">
<summary>
 try get assembly that is loaded in current appdomain
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.Utils.Convert.toBase32String(System.Byte[])">
<summary>
 convert bytes to base-32 string: useful for file names in case-insensitive file systems
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.Utils.Convert">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.Utils.Option">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.Utils.Exn">

</member>
<member name="T:Nessos.Vagabond.Utils">

</member>
<member name="">

</member>
<member name="T:System.AssemblyVersionInformation">

</member>
</members>
</doc>
